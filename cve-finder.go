package main

import (
	"bufio"
	"bytes"
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"os/signal"
	"strings"
	"syscall"

	"github.com/fatih/color"
	"github.com/schollz/progressbar/v3"
)

type ExploitResponse struct {
	Description string              `json:"description"`
	Entries     map[string][]string `json:"entries"`
	NextPage    string              `json:"next_page"`
}

func main() {
	// Define command-line flags
	cveFlag := flag.String("cve", "", "CVE keyword to search for")

	// Set custom usage message
	flag.Usage = func() {
		fmt.Fprintf(os.Stderr, "Usage: %s -cve CVE-XXXX-XXXX/X\n", os.Args[0])
		fmt.Fprintln(os.Stderr, "Options:")
		flag.PrintDefaults()
	}

	// Parse command-line flags
	flag.Parse()

	// Check if the -cve flag is provided
	if *cveFlag == "" || !isValidCVEKeyword(*cveFlag) {
		flag.Usage()
		return
	}

	// Prompt the user to confirm saving to file
	saveToFileFlag := askYesNo("Do you want to save the results to a file? (Y/N): ")

	// Set up logger
	logger := setupLogger("exploit.log")

	// Set up signal handler for graceful shutdown
	sigCh := make(chan os.Signal, 1)
	signal.Notify(sigCh, syscall.SIGINT, syscall.SIGTERM)

	// Print the results header
	color.Cyan("Exploit Observer Results:")

	// URL of the API with the provided CVE keyword
	apiURL := fmt.Sprintf("https://api.exploit.observer/?keyword=%s", *cveFlag)

	// Fetch data from the API
	exploitResponse := fetchExploitData(apiURL, logger)

	// Process and save results
	processResults(exploitResponse, logger, saveToFileFlag)

	// Handle graceful shutdown
	<-sigCh
	logger.Println("Received signal, shutting down...")
}

func isValidCVEKeyword(keyword string) bool {
	// Split the keyword by dashes
	parts := strings.Split(keyword, "-")
	if len(parts) != 3 {
		return false
	}

	// Check if the second part (XXXX) has exactly 4 characters
	if len(parts[1]) != 4 {
		return false
	}

	// Check if the third part (XXXXX) has between 1 and 5 characters
	if len(parts[2]) < 1 || len(parts[2]) > 5 {
		return false
	}

	return true
}

func fetchExploitData(apiURL string, logger *log.Logger) ExploitResponse {
	// Make GET request to the API
	response, err := http.Get(apiURL)
	if err != nil {
		logger.Fatalf("Error making GET request: %v", err)
	}
	defer response.Body.Close()

	var bar *progressbar.ProgressBar
	if response.ContentLength > 0 {
		// Create a progress bar if the response size is known
		bar = progressbar.DefaultBytes(
			response.ContentLength,
			"Downloading data:",
		)
	} else {
		// Create an indeterminate progress bar if the response size is unknown
		bar = progressbar.Default(-1, "Downloading data:")
	}

	// Create a new buffer to store the response data
	var buf bytes.Buffer

	// Copy the response body to the buffer with progress tracking
	_, err = io.Copy(io.MultiWriter(&buf, bar), response.Body)
	if err != nil {
		logger.Fatalf("Error reading response data: %v", err)
	}

	// Check if the buffer is empty
	if buf.Len() == 0 {
		logger.Fatalf("Error: Received empty response from the server")
	}

	// Decode the JSON response
	var exploitResponse ExploitResponse
	err = json.NewDecoder(&buf).Decode(&exploitResponse)
	if err != nil {
		logger.Fatalf("Error decoding JSON response: %v", err)
	}

	return exploitResponse
}

func processResults(exploitResponse ExploitResponse, logger *log.Logger, saveToFileFlag bool) {
	// Append the ASCII art to the description
	exploitResponse.Description = "\n" + exploitResponse.Description

	// Log specific information with formatting
	logger.Printf("Description: %s\n", exploitResponse.Description)
	logger.Println("Entries:")
	for fileType, urls := range exploitResponse.Entries {
		logger.Printf("- %s:\n", fileType)
		for _, url := range urls {
			logger.Printf("  - %s\n", url)
		}
	}

	// Print specific information with formatting to CLI
	color.Green("Description: %s", exploitResponse.Description)
	color.Yellow("Entries:")
	for fileType, urls := range exploitResponse.Entries {
		color.Cyan("- %s:", fileType)
		for _, url := range urls {
			color.Magenta("  - %s", url)
		}
	}

	// Save results to file only if the flag is set to true
	if saveToFileFlag {
		if err := saveResultsToFile(exploitResponse, "exploit_results.txt", logger); err != nil {
			logger.Fatalf("Error saving results to file: %v", err)
		} else {
			logger.Println("Results saved to file: exploit_results.txt")
		}
	}
}

func askYesNo(question string) bool {
	fmt.Print(question)
	reader := bufio.NewReader(os.Stdin)
	response, _ := reader.ReadString('\n')
	return strings.TrimSpace(strings.ToUpper(response)) == "Y"
}

func setupLogger(logFilePath string) *log.Logger {
	logFile, err := os.OpenFile(logFilePath, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
	if err != nil {
		log.Fatalf("Failed to open log file: %v", err)
	}

	return log.New(io.MultiWriter(logFile, os.Stdout), "", log.Ldate|log.Ltime|log.LUTC)
}

func saveResultsToFile(exploitResponse ExploitResponse, filename string, logger *log.Logger) error {
	file, err := os.Create(filename)
	if err != nil {
		return fmt.Errorf("error creating file: %v", err)
	}
	defer file.Close()

	writer := bufio.NewWriter(file)
	defer writer.Flush()

	_, err = writer.WriteString(fmt.Sprintf("Description: %s\n", exploitResponse.Description))
	if err != nil {
		return fmt.Errorf("error writing description to file: %v", err)
	}

	_, err = writer.WriteString("Entries:\n")
	if err != nil {
		return fmt.Errorf("error writing entries to file: %v", err)
	}

	for fileType, urls := range exploitResponse.Entries {
		_, err = writer.WriteString(fmt.Sprintf("- %s:\n", fileType))
		if err != nil {
			return fmt.Errorf("error writing file type to file: %v", err)
		}
		for _, url := range urls {
			_, err = writer.WriteString(fmt.Sprintf("  - %s\n", url))
			if err != nil {
				return fmt.Errorf("error writing URL to file: %v", err)
			}
		}
	}

	return nil
}
